# 为什么要使用消息队列

1. 解耦
2. 异步
3. 流量削峰填谷

![](.\pic\mq\为什么用消息中间件.jpg)

# 消息队列的缺点

1. 可用性降低（又多了一个中间件，如果挂了也会造成系统崩溃，系统越多，可用性越低）
2. 复杂性提高（需要生产者和消费者，消息重复，消息丢失问题）
3. 一致性问题（B系统和C系统的数据库一致性问题）

# 常见消息队列比较

![](.\pic\mq\常见消息队列比较.png)

# RabbitMQ中的vhost起什么作用

vhost可以理解为虚拟broker，即一个迷你版的RabbitMQ server。其内部均含有独立的queue、exchange和binding等，但最重要的是，其拥有独立的权限系统，可以做到vhost范围的用户控制。当然，从RabbitMQ的全局角度，vhost可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同的vhost中）

# RabbitMQ上的一个queue中存放的message是否有数量限制

默认情况下一般是无限制，因为限制取决于机器的内存，但是消息过多会导致处理效率的下降。同时可以通过参数来限制，x-max-length：对队列中消息的条数进行限制，x-max-length-bytes：对队列中消息的总量进行限制

# RabbitMQ中的AMQP

- Exchange交换机

  消息交换机，他指定消息按什么规则，路由到哪个队列

- Queue队列

  消息的载体，每个消息都会被投到一个或多个队列

- Binding绑定

  它的作用就是把exchange和queue按照路由规则绑定起来

- RouteKey路由键

  exchange根据这个关键字进行消息投递

- 生产者

  就是投递消息的程序

- 消费者

  就是接收消息的程序

- Broker

  他提供一种传输服务，他的角色就是维护一条从生产者到消费者的路线，保证数据能够按照指定的方式进行传输（就是RabbitMQ，进程）

- vhost

  虚拟主机，一个broker中可以有多个vhost，用作不同用户的权限分离

- Channel

  消息通道，在客户端的每个连接里，可以建立多个channel

![](.\pic\mq\AMQP协议.jpg)

# RabbitMQ开启持久化机制，有什么要注意的点

持久化，即将原本存在于内存中的数据写入到磁盘上永久保存数据，防止服务宕机时内存数据的丢失。

Rabbitmq 的持久化分为队列持久化、消息持久化和交换器持久化。

对于消息来说，不管是持久化的消息还是非持久化的消息都可以被写入到磁盘。持久化的消息会同时写入磁盘和内存（加快读取速度），非持久化消息会在内存不够用时，将消息写入磁盘（一般重启之后就没有了）。

想要保证消息都不丢失，需要把Exchange、Binding、MessageQueue都持久化，但是开启了持久化性能会急剧下降，只有原来的四分之一，3000并发量

# RabbitMQ的四种交换机类型

- Direct exchange：直连交换机
- Fanout exchange：扇形交换机
- Topic exchange：主题交换机
- Headers exchange：头部交换机（用的少，被直连交换机取代）

## Direct exchange

直连交换机是一种带有路由功能的交换机，一个队列和一个交换机通过routing_key绑定，当消息被发送的时候，需要指定一个routing_key，这个消息被送达交换机的时候，就会被这个交换机送到指定的队列里面，同样的routing_key也是支持应用到多个队列中

![](.\pic\mq\直连交换机.png)

## Fanout exchange

不需要通过routing_key发送给特定的队列，扇形交换机会把能接收到的消息全部发送给绑定在自己身上的队列。因为广播不需要思考，所以扇形交换机处理消息的速度也是所有交换机类型里面最快的。

![](.\pic\mq\扇形交换机.png)

## Topic exchange

发送到主题交换机上的消息需要携带指定规则的routing_key，主题交换机会根据与他绑定的队列的规则将数据发送到对应的（多个）队列上

交换机和队列的binding_key需要采用*.#.。。。的格式，每个部分用.分开，其中：

- *表示一个单词
- #表示任意数量（零个或多个）单词

当一个队列的绑定键为#的时候，这个队列将会无视消息的路由键，接收所有的消息

## Headers exchange

通过消息头判断消息路由到哪个队列中

# 如何解决MQ重复消费问题

重复消费问题是任何MQ都可能出现的问题，以下是一些常见的因素：

1. 生产者：生产者可能会重复推送一条数据到MQ中，比如Controller接口被重复调用了2次，没有做接口幂等性导致的
2. MQ：在消费者消费完准备响应ack消息消费成功时，MQ突然挂了，导致MQ以为消费者还未消费该条数据，MQ恢复后再次推送了该条消息，导致了重复消费
3. 消费者：消费者在处理消息时可能会遇到各种故障，如应用程序崩溃、处理超时或由于某种原因终止等。如果如果MQ在这些情况下未能收到消费者的确认消息，它会认为消息未被消费并重新发送，从而导致重复消费
4. 网络问题：在消息处理过程中，当MQ向消费者推送消息后，消费者需要向MQ返回ack以告知所推送的消息以及消费成功。然而由于网络波动等原因，可能导致消费者向MQ返回的ack丢失。在这种情况下，MQ在长时间内（如一分钟）未收到ack，会认为消费者没有成功处理该消息，从而再次推送该消息给消费者，导致重复消费

解决方案（主要是幂等性处理）：

1. 乐观锁：MVCC多版本并发控制（生产的时候带上数据版本号）

   > 会出现假如有多个更新操作在队列中，使用的是同一个版本号，当第一个更新操作成功后会将版本号+1，导致后续更新操作全部失效

2. 利用数据库唯一键约束

   > 只对新增的数据有效果，而且是通过数据库的约束判断的，效率不够高

3. 去重表的方案：A（id 唯一）

   每个消息带一个唯一id，执行前先把id插入表中，如果插入成功代表消息没有被消费过，设置状态为执行中，成功执行后将状态改为执行成功，如果插入失败，则判断消息状态是否为执行成功，如果不是则重新投递，延迟消费，否则就可以丢弃消息。还需要一个字段记录执行次数，如果执行次数过多还没有成功说明这条消息有问题需要人工干预，每执行一次+1，定时任务判断哪条消息执行次数过多，通知开发人员

   > 如果不设置状态会出现，第一个消费消息的消费者插入了数据，但是执行失败，其他消费者看到表中已有这条消息会当作消费成功而不会再次消费了
   >
   > 如果不设置执行次数会导致如果一直不能成功消费，则资源被占用，队列被占用，其他的消息无法被消费

# RabbitMQ的几种部署方案

- 单机

  最简单的情况，非集群模式，节点挂了，消息就不能用了，业务可能瘫痪，只能等待

- 集群

  消息只会存在当前节点中，并不会同步到其他节点，当前节点宕机，有影响的业务会瘫痪，只能等待节点恢复重启可用（必须是持久化消息情况下）

- 镜像集群

  消息会同步到其他节点上，可以设置同步的节点个数，但吞吐量会下降。属于RabbitMQ的HA（高可用）方法

## 镜像模式

- 同步至所有的
- 同步最多N个机器
- 只同步至符合指定名称的nodes

# RabbitMQ消息丢失解决方案

## RabbitMQ丢失消息的3种情况

![](.\pic\mq\消息丢失三种情况.png)

1. 生产者弄丢了数据。生产者将数据发送到RabbitMQ的时候，可能数据就在半路给搞丢了，因为网络问题啥的，都有可能
2. RabbitMQ弄丢了数据，MQ还没有持久化就宕机了
3. 消费者弄丢了数据，刚消费到，还没处理，自己就挂了，比如重启了

## 解决方案

### 针对生产者

1. 开启RabbitMQ事务

   可以选择用RabbitMQ提供的事务功能，就是生产者发送数据之前开启RabbitMQ事务channel.txSelect，然后发送消息，如果消息没有成功被RabbitMQ接收到，那么生产者会收到异常报错，此时就可以回滚事务channel.txRollback，然后重试发送消息；如果收到了消息，那么可以提交事务channel.txCommit

   ```java
   channel.txSelect();
   try {
       // 这里发送消息
   } catch (Exception e) {
       channel.txRollback();
       // 这里再次重发这条消息
   }
   // 提交事务
   channel.txCommit();
   ```

   缺点：

   RabbitMQ事务机制是同步的，提交一个事务之后会阻塞在那，采用这种方式吞吐量会下来，因为太耗性能

2. 使用confirm机制（发布确认）

   事务机制和confirm机制最大的不同在于，事务机制是同步的，提交一个事务之后会阻塞在那，但是confirm机制是异步的

   在生产者开启了confirm模式之后，每次写的消息都会分配一个唯一的id，然后如果写入了RabbitMQ之中，RabbitMQ会给你回传一个ack消息，告诉你这个消息发送OK了；如果RabbitMQ没能处理这个消息，会回调你一个nack接口，告诉你这个消息失败了，你可以进行重试。而且你可以结合这个机制知道自己在内存里维护每个消息的id，如果超过一定事件还没接收到这个消息的回调，可以重新发送

   ```java
   // 发送成功回调
   public void ack(String messageId) {
       
   }
   // 发送失败回调
   public void nack(String messageId) {
       
   }
   ```

### 针对RabbitMQ

1. 消息持久化
   - Exchange 设置持久化
   - Queue 设置持久化
   - Message 持久化发送：发送消息设置发送模式deliveryMode=2，代表持久化消息
2. 设置集群镜像模式
3. 消息补偿机制

### 针对消费者

1. ACK确认机制

   多个消费者同时收到消息，比如消息接收到一半的时候，一个消费者死掉了（逻辑复杂时间太长，超时了或者消费被停机或者网络断开连接），如何保证消息不丢失

   使用RabbitMQ提供的ack机制，服务端首先关闭RabbitMQ的自动ack，然后每次在确保处理完这个消息后，在代码里手动调用ack。这样就可以避免消息还没有处理完就ack，才把消息从内存中删除

   这样即使一个消费者出了问题，但不会同步消息给服务端，会有其他的消费者去消费，保证了消息不丢

   > 但如果消息处理完，发送ack失败，导致消息没有被RabbitMQ删除，可能可以用消息重复消费问题解决，幂等性消息

通过以上的处理，理论上不存在消息丢失的情况，但是系统的吞吐量以及性能有所下降。在实际开发中，需要考虑消息丢失的影响程度，来做出对可靠性以及性能之间的权衡

# 死信队列

DLX（Dead Letter Exchange），死信交换机

当队列中的消息被拒绝、或者过期会变成死信，死信可以被重新发布到另一个交换机，这个交换机就是DLX，与DLX绑定的队列称为死信队列

造成死信的原因：

- 消息被拒绝
- 消息超时
- 超过了队列的最大长度

# 过期消息

在RabbitMQ中存在两种方式可以设置消息的过期时间，第一种通过对队列进行设置，这种设置后，该队列中所有的消息都存在相同的过期时间，第二种通过对消息本身进行设置，那么每条消息的过期时间都不一样。如果同时使用这两种方法，那么以过期时间小的那个数值为准。当消息达到过期时间还没有被消费，那么这个消息就成为了一个死信消息

队列设置：在队列申明的时候使用x-message-ttl参数，单位为毫秒

单个消息设置：是设置消息属性的expiration参数的值，单位为毫秒

# 延迟队列

延迟队列存储的是延迟消息

延迟消息指的是，当消息被发布出去之后，并不立即投递给消费者，而是在指定时间之后投递。如：

在订单系统中，订单有30秒的付款时间，在订单超时之后在投递给消费者处理超时订单（判断是否支付，做相应的处理）

RabbitMQ没有直接支持延迟队列，可以通过死信队列实现

在死信队列中，可以为普通交换机绑定多个消息队列，假设绑定过期时间为5分钟，10分钟和30分钟，3个消息队列，然后为每个消息队列设置DLX，为每个DLX关联一个死信队列

当消息过期之后，被转存到对应的死信队列中，然后投递给指定的消费者消费

# 队列满了怎么办

丢到死信队列中存到数据库里，后期补偿消费

# RabbitMQ如何解决消息堆积问题

1. 消费者处理消息的速度太慢
   - 增加消费者数量：通过水平扩展，增加消费者的数量来提高处理能力
   - 优化消费者性能：提高消费者处理消息的效率，例如优化代码、增加资源
   - 消息预取限制（prefetch count）：调整消费者的预取数量以避免一次处理过多消息而导致处理缓慢
2. 队列的容量太小
   - 增加队列的容量：调整队列设置以允许更多消息存储
3. 网络故障
   - 监控和告警：通过监控网络状况并设置告警，确保在网络故障时快速发现并解决问题
   - 持久性和高可用性：确保消息和队列的持久化以避免消息丢失，并使用镜像队列提高可用性
4. 消费者故障
   - 使用死信队列：将无法处理的消息转移到死信队列，防止阻塞主队列
   - 容错机制：实现消费者的自动重启和错误处理逻辑
5. 队列配置不当
   - 优化队列配置：检查并优化消息确认模式、队列长度限制和其他相关配置
6. 消息大小
   - 消息分片：将大型消息分割成小的消息片段，加快处理速度
7. 业务逻辑复杂或耗时
   - 优化业务逻辑：简化消费者中的业务逻辑，减少处理每个消息所需的时间
8. 消息产生速度快于消费速度
   - 使用消息限流：控制消息的生产速度，确保他不会超过消费者的处理能力
   - 负载均衡：确保消息在消费者之间公平分配，避免个别消费者过载
9. 其他配置优化
   - 消息优先级：使用消息优先级确保高优先级消息优先处理
   - 调整RabbitMQ配置：优化RabbitMQ服务的配置，如文件描述符限制、内存使用限制等