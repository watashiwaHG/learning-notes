# InnoDB和MyISAM的区别

mysql最常用的两种存储引擎

- 事务和外键

  InnoDB支持事务和外键，具有安全性和完整性，适合大量insert或update操作

  MyISAM不支持事务和外键，它提供高速存储和检索，适合大量的select查询操作

- 锁机制

  InnoDB支持行级锁，锁定指定记录。基于索引来加锁实现

  MyISAM支持表级锁，锁定整张表

- 索引结构

  InnoDB使用聚簇索引，索引和记录在一起存储，既缓存索引，也缓存记录

  MyISAM使用非聚簇索引，索引和记录分开

- 并发处理能力

  MyISAM使用表锁，会导致写操作并发率低，读之间并不阻塞，读写阻塞

  InnoDB读写阻塞可以与隔离级别有关，可以采用多版本并发控制（MVCC）来支持高并发

- 存储文件

  InnoDB表对应两个文件，一个.frm表结构文件，一个.ibd数据文件。InnoDB表最大支持64TB

  MyISAM表对应三个文件，一个.frm表结构文件，一个.MYD表数据文件，一个.MYI索引文件。从Mysql5.0开始默认限制是256TB

MyISAM适用场景

- 不需要事务支持（不支持）
- 并发相对较低（锁定机制问题）
- 数据修改相对较少，以读为主
- 数据一致性要求不高

InnoDB适用场景

- 需要事务支持（具有较好的事务特性）
- 行级锁定对高并发有很好的适应能力
- 数据更新较为频繁的场景
- 数据一致性要求较高
- 硬件设备内存较大，可以利用InnoDB较好的缓存能力来提高内存利用率，减少磁盘IO

两种引擎该如何选择？

- 是否需要事务？有，InnoDB
- 是否存在并发修改？有，InnoDB
- 是否追求快速查询，且数据修改少？是，MyISAM
- 在绝大多数情况下，推荐使用InnoDB

# B树、B+树

## B-Tree

B树是一种平衡的多路查找树，B树允许一个节点存放多个数据，这样可以在尽可能减少树的深度的同时，存放更多的数据（把瘦高的树变得矮胖）

B树中所有的节点的子树个数的最大值成为B树的阶，用m表示一颗m阶的B树，如果不为空，就必须满足以下条件

1. 每个节点最多拥有m-1个关键字（根节点除外），也就是m个子树
2. 根节点至少有两个子树（可以没有子树，有就至少是两个）
3. 分支节点至少有m/2棵子树（除去根节点和叶子节点其他都是分支节点）
4. 所有叶子节点都在同一层，并且以升序排序

![](.\pic\mysql\B树.jpg)

### B树结构存储索引的特点

为了描述B树首先定义一条记录为一个键值对[key,data]，key为记录的键值，对应表中的主键值（聚簇索引），data为一行记录中除主键外的数据。对于不同的记录，key值互不相同

- 索引值和data数据分布在整棵树结构中
- 白色块部分是指针，存储着子节点的地址信息
- 每个节点可以存放多个索引值以及对应的data数据
- 树节点中的多个索引值从左到右升序排列

![](.\pic\mysql\B树索引.jpg)

### B树的查找操作

B树的每个节点的元素可以视为一次I/O读取，树的高度表示最多的I/O次数，在相同数量的总元素个数下，每个节点的元素个数越多，高度越低，查询所需的I/O次数越少

### B树总结

- 优点：B树可以在内部节点存储键值和相关记录数据，因此把频繁访问的数据放在靠近根节点的位置将大大提高热点数据的查询效率
- 缺点：B树中每个节点不仅包含数据的key值，还有data数据，所以当data数据较大时，会导致每个节点存储的key值减少，并且导致B树的层数变高，增加查询时的IO次数
- 使用场景：B树主要应用于文件系统以及部分数据库索引，如MongoDB，大部分关系型数据库索引则是使用B+树实现

## B+Tree

B+Tree是在B树的基础上的一种优化，使其更适合实现存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构，根节点存放在内存

### B+树的特征

- 非叶子节点只存储键值信息
- 所有叶子节点之间都有一个链指针
- 数据记录都存放在叶子节点中

![](.\pic\mysql\B+树索引.png)

### B+树的优势

1. B+树是B树的变种，B树能解决的问题，B+树也能够解决（降低树的高度，增大节点存储数据量）
2. B+树扫库的扫表能力更强，如果我们要根据索引去进行数据表的扫描，对B树进行扫描，需要把整棵树·遍历一遍，而B+树只需要遍历他的所有叶子节点即可（叶子节点之间有引用）
3. B+树磁盘读写能力更强，他的根节点和枝节点不保存数据区，所有根节点和枝节点同样大小的情况下，保存的关键字要比B树要多。而叶子节点不保存子节点引用。所以B+树读写一次磁盘加载的关键字比B树更多
4. B+树排序能力更强，如上面的图中可以看出，B+树天然具有排序功能
5. B+树查询效率更加稳定，每次查询数据，查询IO次数一定是稳定的。当然这个每个人的理解不同，因为在B树如果根节点命中直接返回，确实效率更高

> 局部性原理：
>
> - 时间局部性：之前被查询过的数据很快可能被再次查询
> - 空间局部性：数据和程序都有聚集成群的倾向，具备某一个特点的数据经常聚集存储
>
> 磁盘预读：
>
> 磁盘跟内存在进行交互的时候有一个最基本的逻辑单位，称之为页，每次在进行数据读取的时候一般读取的是页的整数倍，页的大小是跟操作系统相关，默认是4kb或者8kb，在mysql的innodb存储引擎中，页的大小默认是16kb
>
> 尽可能少的产生io次数，能读一次绝对不读两次
>
> 尽可能读取少的数据，减少整体的io量

# Hash索引有哪些优缺点

Mysql中索引的常用数据结构有两种：一种是B+树，另一种则是Hash

Hash底层实现是由Hash表来实现的，是根据键值<key,value>存储数据的结构。非常适合根据key查找value值，也就是单个key查询，或者说等值查询

![](.\pic\mysql\Hash索引.png)

对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，如果出现哈希码值相同的情况会拉出一条链表

Hash索引的优点

- 因为索引自身只需要存储对应的Hash值，所以索引结构非常紧凑，只需要做等值比较查询，而不包含排序或范围查询的需求，都适合使用哈希索引
- 没有哈希冲突的情况下，等值查询访问哈希索引的数据非常快（如果发生Hash冲突，存储引擎必须遍历链表中的所有行指针，逐行进行比较，直到找到所有符合条件的行）

Hash索引的缺点

- 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行，也就是一定会回表，无法做到覆盖索引
- 哈希索引只支持等值比较查询。不支持任何范围查询和部分索引列匹配查找
- 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序

> 1. 必须要设计一个优秀的hash算法，保证你的数据足够散列，如果存在大量的hash冲突或者hash碰撞，那么会导致某些查询效率非常低
>
> 2. 当需要进行范围查询的时候，需要挨个对比每一个元素值，效率极低，在生产环境中大部分的查询是范围
>
> 3. hash比较浪费内存的空间，而内存是非常宝贵的资源（一次性要把hash索引全部放入内存中）
>
>    memory存储引擎支持的是hash索引
>
>    innodb存储引擎支持自适应hash（由mysql自己来决定使用的是hash索引还是B+树索引，人为不能干预，由系统判断，只适用于innodb存储引擎）

# 为什么不能用二叉树、BST（二叉搜索树）、AVL、红黑树做索引

![](.\pic\mysql\不同树的区别.jpg)

每一个分支有且仅有两个子节点，当需要向其中插入更多的数据的时候，就必须要增加树的高度，而增加树的高度会导致树变深，会导致io的次数变多，所以所有的二叉树都是不行的

# 为什么不用跳表做索引

- 在读操作中，B+树和跳表可以近似看作都是logn级别，但B+树的I/O次数更少
  - 跳表几乎是纯纯的logn级别，他的最下层是完整的数据，用指针连接，上一层的节点数量是下一层的1/2，所以当千万条数据时，大概是2的24次方，也就是24层，最差的情况下需要I/O24次才能找到数据
  - B+树大概三层就能存放2kw数据，所以只需要I/O3次，一个页中16kb，存放的数据可以通过二分查找logn查出来
- 在写操作中，跳表的性能会好一些
  - 跳表虽然每次插入靠随机函数计算50%的概率向上一层插入一个新节点，25%的概率向上上层插入新节点。。。。
  - B+树在索引节点没写满和叶子节点没写满的情况下，只需插入就可以，索引节点没写满，叶子节点写满了就要对叶子节点分页，索引节点写满，叶子节点也写满就要对叶子节点和索引节点都做页分裂，并且会多加一层，而且可能伴随这平衡旋转合并的问题，所以性能不高

# 一个B+树索引大概能存放多少条数据

**假设一个B+树高为2，即存在一个根节点和若干个叶子节点，那么这颗B+树的存放总记录数为：根节点指针数*单个叶子节点记录行数**

- 计算根节点指针数：假设表的主键为int类型，占用的就是4个字节，或者是BIGINT占用8个字节，指针大小为6个字节，那么一个页（就是B+树中的一个节点），大概可以存储：16384B/（4B + 6B）=1638，一个节点最多可以存储1638个索引指针
- 计算每个叶子节点的记录数：我们假设一行记录的数据大小为1k，那么一页就可以存储16行数据，16KB/1kB=16
- 一颗高度为2的B+树可以存放的记录数为：1638 * 16 = 26208条数据记录，同样的原理可以推算出一个高度3的B+树可以存放：1638 * 1638 * 16 = 42928704条这样的记录

所以InnoDB中的B+树高度一般为1 - 3 层，就可以满足千万级别的数据存储，在查找数据时一次页的查找代表一次IO，所以通过主键索引查询通常只需要1 - 3次IO操作即可查找到数据

# explain的主要字段

## mysql查询过程

![](.\pic\mysql\mysql查询过程.jpg)

- id： 表的读取顺序
- select_type： 查询类型（简单查询、复杂查询、子查询）
- table： 查询的表
- type： 数据读取操作的操作类型
- possible_keys： 哪些索引可以被使用
- key：哪些索引真正被使用
- key_len：索引被使用的长度，复合索引有用
- ref：显示索引的哪一列被使用了
- rows：每张表有多少行被优化器查询
- Extra

## type字段中有哪些常见的值

type字段显示的是连接类型（join type表示的是用什么样的方式来获取数据），它描述了找到所需数据所使用的扫描方式，是较为重要的一个指标

下面给出各种连接类型，按照从最佳类型到最坏类型进行排序：

``````
system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL

简化之后，我们可以只关注一下几种
system > const > eq_ref > ref > range > index > ALL
``````

> 一般来说，需要保证查询至少达到range级别，最好能到ref，否则就要进行sql的优化调整

| type类型 | 解释                                                         |
| -------- | ------------------------------------------------------------ |
| system   | 不进行磁盘IO，查询系统表，仅仅返回一条数据                   |
| const    | 查找主键索引，最多返回1条或0条数据，属于精确查找             |
| eq_ref   | 查找唯一性索引，返回数据最多一条，属于精确查找               |
| ref      | 查找非唯一性索引，返回匹配某一条件的多条数据，属于精确查找，数据返回可能是多条 |
| range    | 查找某个索引的部分索引，只检索给定范围的行，属于范围查找。比如：>、<、in、between |
| index    | 查找所有索引树，比ALL快一些，因为索引文件要比数据文件小      |
| ALL      | 不使用任何索引，直接进行全表扫描                             |

## Extra有哪些主要指标，各自的含义是什么

Extra是EXPLAIN输出中另外一个很重要的列，该列显示Mysql在查询过程中的一些详细信息

| extra类型             | 解释                                                         |
| --------------------- | ------------------------------------------------------------ |
| Using filesort        | Mysql中无法利用索引完成的排序操作称为”文件排序“              |
| Using index           | 表示直接访问索引就能够获取到所需要的数据（覆盖索引），不需要通过索引回表 |
| Using index condition | 搜索条件中虽然出现了索引列，但是有部分条件无法使用索引，会根据能用索引的条件先搜索一遍，再匹配无法使用索引的条件 |
| Using join buffer     | 使用了连接缓存，会显示join连接查询时，Mysql选择的查询算法，连接列没有索引 |
| Using temporary       | 表示Mysql需要使用临时表来存储结果集，常见于排序和分组查询    |
| Using where           | 意味着全表扫描或者在查找使用索引的情况下，但是还有查询条件不在索引字段中 |

# 如何进行分页查询优化

- 一般性分页

  一般的分页查询使用简单的limit子句就可以实现。limit格式如下：

  ```sql
  SELECT * FROM 表名 LIMIT [offset] rows
  ```

  - 第一个参数指定第一个返回记录行的偏移量，注意从0开始
  - 第二个参数指定返回记录行的最大数目
  - 如果只给定一个参数，他表示返回最大的记录行数目

  **思考1：如果偏移量固定，返回记录量对执行时间有什么影响？**

  ```sql
  select * from user limit 10000,1;
  select * from user limit 10000,10;
  select * from user limit 10000,100;
  select * from user limit 10000,1000;
  select * from user limit 10000,10000;
  ```

  结果：在查询记录时，返回记录量低于100条查询时间基本没有变化，差距不大。随着查询记录量越大，所花费的时间也会越来越多

  **思考2：如果查询偏移量变化， 返回记录数固定对执行时间有什么影响？**

  ```sql
  select * from user limit 1,100;
  select * from user limit 10,100;
  select * from user limit 100,100;
  select * from user limit 1000,100;
  select * from user limit 10000,100;
  ```

  结果：在查询记录时，如果查询记录量相同，偏移量超过100后就开始随着偏移量增大，查询时间急剧的增加。（这种分页查询机制，每次都会从数据库第一条记录开始扫描，越往后查询越慢，而且查询得数据越多，也会拖慢总查询速度）

- 分页优化方案

  **优化1：通过索引进行分页**

  直接进行limit操作会产生全表扫描，速度很慢。limit限制的是从结果集的M位置处取出N条输出，其余抛弃，假设ID是连续递增的，我们根据查询的页数和查询的记录数是可以算出查询的id的范围，然后配合limit使用

  ```sql
  SELECT * FROM user WHERE id >= 100001 LIMIT 100;
  ```

  **优化2：利用子查询优化**

  ```sql
  -- 首先定位偏移量位置的id
  SELECT id FROM user_contacts LIMIT 100000,1;
  
  -- 根据获取到的id值向后查询
  SELECT * FROM user_contacts WHERE id >= 
  	(SELECT id FROM user_contacts LIMIT 100000,1) 
  	LIMIT 100;
  ```

  原因：使用了id做主键比较（id>=）,并且子查询使用了覆盖索引进行优化

# 如何做慢查询优化

## Mysql慢查询的相关参数解释：

- **slow_query_log**：是否开启慢查询日志，ON(1)表示开启，OFF(0)表示关闭
- **slow-query-log-file**：新版（5.6及以上版本）Mysql数据库慢查询日志存储路径
- **long_query_time**：慢查询阈值，当查询时间多于设定的阈值时，记录日志

## 日志内容

我们得到慢查询日志后，最重要的一步就是去分析这个日志。

如下图是慢日志里其中一条sql的记录内容，可以看到有时间戳，用户，查询时长及具体的sql等信息

![](.\pic\mysql\慢查询日志.jpg)

- Time：执行时间
- User：用户信息，Id信息
- Query_time：查询时长
- Lock_time：等待锁的时长
- Rows_sent：查询结果的行数
- Rows_examined：查询扫描的行数
- SET timestamp：时间戳
- sql的具体信息

## 慢查询sql优化思路

### sql性能下降的原因

在日常的运维过程中，经常会遇到DBA将一些执行效率较低的sql发过来找开发人员分析，当我们拿到这个sql语句之后，在对这些sql进行分析之前，需要明确可能导致sql执行性能下降的原因进行分析，执行性能下降可以体现在以下两个方面：

- 等待时间长

  ```锁表导致查询一直处于等待状态，后续我们从mysql锁的机制去分析sql执行的原理```

- 执行时间长

  ``````
  1.查询语句写的烂
  2.索引失效
  3.关联查询太多join
  4.服务器调优以及各个参数的设置
  ``````

### 慢查询优化思路

1. 优先选择优化高并发执行的sql，因为高并发的sql发生问题带来后果更严重

   ``````
   比如下面两种情况：
   	SQL1：每小时执行10000次，每次20个IO，优化后每次18个IO，每小时节省2w次IO
   	SQL2：每小时10次，每次20000个IO，每次优化减少2000个IO，每小时节省2w次IO
   	SQL2更难优化，SQL1更好优化，但是第一种属于高并发SQL，更急需优化 成本更低
   ``````

2. 定位优化对象的性能瓶颈（在优化之前了解性能瓶颈在哪）

   ``````
   在去优化sql时，选择优化方向有三个：
   	1.IO（数据访问消耗了太多的时间，查看是否正确使用了索引）
   	2.CPU（数据运算花费了太多时间，数据的运算分组，排序是不是有问题）
   	3.网络带宽（加大网络带宽）
   ``````

3. 明确优化目标

   ``````
   需要根据数据库当前的状态
   数据库中与该条sql的关系
   当前sql的具体功能
   最好的情况消耗的资源，最差情况下消耗的资源，优化的结果只有一个给用户一个好的体验
   ``````

4. 从explain执行计划入手

   ``````
   只有explain能告诉你当前sql的执行状态
   ``````

5. 永远用小的结果集驱动大的结果集

   ``````
   小的数据集驱动大的数据集，减少内层表读取的次数
   
   类似于嵌套循环
   for (int i = 0; i < 5; i++) {
   	for (int j = 0; j < 1000; j++) {
   	
   	}
   }
   如果小的循环在外层，对于数据库连接来说就只连接5次，进行5000次操作，如果1000在外，则需要进行1000次数据库连接，从而浪费资源，增加消耗。这就是为什么要小表驱动大表
   ``````

6. 尽可能在索引中完成排序

   ``````
   排序操作用的比较多，order by后面的字段如果在索引中，索引本来就是排好序的，所以速度很快，没有索引的话，就需要从表中拿数据，在内存中进行排序，如果内存空间不够还会发生落盘操作
   ``````

7. 只获取自己需要的列

   ``````
   不要使用select *,select *很可能不走索引，而且数据量过大
   ``````

8. 只使用最有效的过滤条件

   ``````
   误区 where后面的条件越多越好，但实际上是应该用最短的路径访问到数据
   ``````

9. 尽可能避免复杂的join和子查询

   ``````
   每条sql的join操作，建议不要超过三张表
   将复杂的sql，拆分成多个小sql，单个表执行，获取的结果，在程序中进行封装
   如果join占用的资源比较多，会导致其他进程等待时间变长
   ``````

10. 合理设计并利用索引

    ``````
    如何判定是否需要创建索引？
     1.较为频繁的作为查询条件的字段应该创建索引
     2.唯一性太差的字段不适合单独创建索引，即便频繁作为查询条件。（唯一性太差的字段主要是指哪些呢？如状态字段，类型字段等等这些字段中的数据可能总共就是那么几个几十个数值重复使用）（当一条Query所返回的数据超过了全表的15%的时候，mysql就不再使用索引扫描来完成这个Query了，因为会全表扫描）
     3.更新非常频繁的字段不适合创建索引（因为索引中的字段被更新的时候，不仅仅需要更新表中的数据，同时还要更新索引数据，以确保索引信息是准确的）
     4.不会出现在where子句中的字段不该创建索引
     
    如果选择合适的字段作为索引？
     1.对于单键索引，尽量选择针对当前Query过滤性更好的字段作为索引
     2.选择联合索引时，当前Query中过滤性最好的字段在索引字段顺序中排列要靠前
     3.选择联合索引时，尽量索引字段出现在where中比较多的索引
    ``````
