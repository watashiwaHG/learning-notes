# TCP协议和UDP协议

![](.\pic\计算机网络\网络协议.jpg)

TCP协议和UDP协议都在传输层

## TCP协议的三次握手

![](.\pic\计算机网络\TCP三次握手.png)

- 第一次握手

  客户端向服务端发送SYN=1，seq=x

- 第二次握手

  服务端向客户端发送SYN=1，ACK=1，ack = x + 1，seq=y

- 第三次握手

  客户端向服务端发送ACK=1，ack = y + 1，seq=x + 1

> SYN 同步位 
>
> - SYN = 1 表示进行一个连接请求
>
> ACK 确认位
>
> - ACK = 1 表示成功
>
> - ACK = 0 表示失败
>
> ack 确认号，对方发送序号+1
>
> seq 序号

第三次握手的时候是允许携带数据的，并且在第三次握手之后，客户端已经可以向服务端发送数据了，如果第三次握手丢失或者晚于数据包，则数据包会被当初第三次握手

**为什么不能两次握手？**

主要为了确认客户端和服务端的发送和接收能力都正常，如果只有两次，客户端可以随便向服务端发送数据，但是服务端将不知道客户端的接收能力是否正常，不敢发送消息，违背了全双工的定义

如果服务端在发送SYN+ACK包后就建立连接，会出现已失效的请求报文突然传到服务器引起错误，如果客户端刚开始发送了一个SYN包，但由于网络阻塞迟迟没有到达服务端，客户端会重新发送一个SYN包，这次数据正常送达，服务端返回SYN+ACK建立连接，而此时第一次发送的SYN包突然到达服务端，服务端会以为是客户端发送了一个新的连接，依然会返回SYN+ACK并建立连接，对于客户端来说只建立了一次连接，而对于服务端来说建立了两次连接，出现了状态不一致。如果是三次握手的话，客户端在收到第二次SYN+ACK包后不会发送ACK包，也就不会建立第二次连接。

所以三次握手就是为了能够在不可靠的信道上建立可靠的连接

### TCP的丢包问题和乱序问题

![](.\pic\计算机网络\乱序问题丢包问题.png)

发送方将数据发到发送缓冲中，每次只发送一部分连续的数据，并且携带序列号和长度。接受方接受到发送报文后，回复下一个包的起始序列号（序列号+长度）代表接收成功，可以采取这样一问一答的形式，发送方也可以一次性发送连续的多包数据，接收方只需要回复一次ACK就可以了。之后接收方把接收到的所有包按照序列号和长度进行数据重组，如果中间有缺失的数据，则根据序列号发送给发送方，发送方将会重新发送

## TCP的四次挥手

![](.\pic\计算机网络\TCP四次挥手.png)

- 第一次挥手

  客户端发送FIN包给服务端，FIN=1，seq=u，进入FIN-WAIT-1状态，此时客户端不会再向服务端发送数据

- 第二次挥手

  服务端发送ACK包给客户端，ACK=1，ack=u+1，seq=v，进入CLOSE-WAIT状态，客户端进入FIN-WAIT-2状态

- 这个过程中服务端可以将未发送的数据发送给客户端，客户端还可以接收数据

- 第三次挥手

  服务端发送完所有数据后，发送FIN包给客户端，FIN=1，ACK=1，ack=u+1，seq=w，进入LAST-ACK最后确认状态

- 第四次挥手

  客户端发送ACK包给服务端，ACK=1，ack=w +1，seq=u+1，进入TIME-WAIT超时等待状态，服务端此时进入关闭状态，客户端经过超时时间后关闭连接

> FIN = 1 断开连接

**为什么不能三次挥手？**



**为什么客户端需要超时等待？**

因为如果客户端在第四次挥手之后就释放了连接，一旦最后的ACK包丢失，服务端没有接收到，服务端将一直停留在LAST-ACK状态无法关闭，所以有超时等待的话，服务端在没有接收到ACK包后就可以重新发送FIN包，客户端接收到FIN包后重新发送ACK包并且刷新超时时间

所以四次挥手就是为了能够在不可靠的信道上建立可靠的断开

## 总结

- TCP

  基于连接（安全可靠，类似打电话）

- UDP

  基于非连接（不安全可靠，类似写信），速度快，简单的将数据封装一下就发送出去，数据包之间没有状态上的联系（无状态），性能损耗少，对于CPU内存的占用也小，但丢包的问题不能解决，稳定性低

# HTTP协议

超文本传输协议（HyperText Transfer Protocol，HTTP）：

一种无状态的（不记录用户状态）、以请求/应答的方式运行的协议，他使用可扩展的语义（请求头、响应头可以自定义字段）和自描述消息格式，与基于网络的超文本信息系统灵活的互动

## 主要特点

- **http1.0**

  简单快速：当客户端向服务端发送请求时，只是简单的填写请求路径和请求方法即可，然后就可以通过浏览器或其他方式将该请求发送

  灵活：HTTP协议允许客户端和服务器端传输任意类型任意格式的数据对象

  - 无连接：无连接的含义是限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间（当今多数服务器支持Keep-Alive功能，使用服务器支持长连接，解决无连接的问题）
  - 无状态：无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即客户端发送HTTP请求后，服务器根据请求，会给我们发送数据，发送完后，不会记录信息（使用cookie机制可以保持session，解决无状态的问题）

- **http1.1**

  - 默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求
  - 管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应
  - 断点续传，就是可以将一个大数据，分段传输，客户端可以慢慢显示

- **http2.0**

  - HTTP/2采用二进制格式而非文本格式
  - HTTP/2是完全多路复用的，而非有序并阻塞的——只需一个HTTP连接就可以实现多个请求响应
  - 使用报头压缩，HTTP/2降低了开销
  - HTTP/2让服务器可以将响应主动“推送”到客户端缓存中

## HTTP报文格式

HTTP协议的请求报文和响应报文的结构基本相同，由三大部分组成：

- 起始行（start line）：描述请求或相应的基本信息

  请求：GET /index.html HTTP/1.1

  | METHOD | 空格 | URL  | 空格 | VERSION | 换行 |
  | ------ | ---- | ---- | ---- | ------- | ---- |

  - 请求方法：如GET/HEAD/PUT/POST，表示对资源的操作
  - URL：标记了要操作的资源
  - 协议版本：表示报文使用的HTTP协议版本 

  响应：HTTP/1.1 200 OK

  | VERSION | 空格 | STATUS CODE | 空格 | REASON | 换行 |
  | ------- | ---- | ----------- | ---- | ------ | ---- |

  - 协议版本：表示报文使用的HTTP协议版本 
  - 状态码：一个三位数，用代码的形式表示处理的结果，比如200是成功，500是服务器错误
  - 原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因

  

- 头部字段集合（header）

  使用key-value形式更详细的说明报文，key和value之间用“:”分割，最后用CRLF换行表示字段结束。比如前后端分离时经常遇到的与后端协商传输数据的类型“Content-type:application/json”，这里key就是“Content-type”，value就是“application/json”。HTTP头字段非常灵活，不仅可以使用标准里的Host、Connection等已有头，也可以任意添加自定义头，这就给HTTP协议带来了无限的扩展可能

  > 头字段注意事项
  >
  > - 字段名不区分大小写，字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“\_”（有的服务器不会解析带“_”的头字段）字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格
  > - 字段的顺序是没有意义的，可以任意排列不影响语义
  > - 字段原则上不能重复，除非这个字段本身的语义允许，例如：Set-Cookie

  常用头字段

  HTTP协议中有非常多的头字段，但基本上可以分为四大类：

  - 请求字段：请求头中的头字段；如Host，Referer
  - 响应字段：响应头中的头字段；如Server
  - 通用字段：在请求头和响应头里都可以出现，如Content-type，Connection
  - 自定义字段

- 空行

- 消息正文（entity）：实际传输的数据，他不一定是纯文本，可以是图片、视频等二进制数据



# HTTPS是什么

HTTP + TLS/SSL，主要对HTTP传输的数据进行加密

## 对称加密和非对称加密

- 对称加密

  加密和解密用的都是同一个密钥的加密形式

- 非对称加密

  加密和解密用的不是同一个密钥，分为公钥和私钥，私钥加密的数据只能用公钥解密，公钥加密的数据只能用私钥解密

  > 非对称加密的原理就是大数取模
  >
  > 将5加密，x是密钥，结果为4
  >
  > 5^x mod 56804605609 = 4
  >
  > 已知的情况下，反过来求密钥，这样的一个等式求x对于计算机来说只能一个一个去试，时间非常久，可以近似看成解不出来，是不可逆的
  >
  > 原文^p*q mod N = 原文
  >
  > 原文^p mod N = 密文
  >
  > 密文^q mod N = 原文
  >
  > 验证数字签名

## **HTTPS加密过程**

- TCP三次握手

- 加密流程

  - TLS四次握手

    - 第一次握手

      客户端告诉服务端支持的加密协议版本（TLS1.2），加密套件（RSA），客户端随机数client random

    - 第二次握手

      服务端告诉客户端确定的加密协议版本和加密套件，服务器证书（经过CA的私钥加密过的服务器公钥）和服务器随机数server random

    - 第三次握手

      客户端从服务器证书中获取服务器公钥（通过CA的公钥解密服务器证书），并且用公钥加密第三个随机数pre_master_key，用三个随机数得到一个会话密钥，把迄今为止的通信数据内容生成一个摘要finished报文并用会话密钥加密，将pre_master_key和finished报文发送给服务器

    - 第四次握手

      服务器使用服务器私钥解密被公钥加密的pre_master_key获取到第三个随机数，用三个随机数使用同样的算法生成一个会话密钥，把迄今为止的通信数据内容生成一个摘要finished报文并用会话密钥加密，把finished报文发送给客户端校验

  - 加密通信

    使用会话密钥进行对称加密通信

就是在TLS四次握手的过程中生成三个随机数，通过三个随机数生成一个会话密钥，之后就通过会话密钥进行加密通信

## **HTTPS使用的是对称加密还是非对称加密**

TLS四次握手使用的是非对称加密，加密通信使用的是对称加密，对称加密比非对称加密速度快

# RPC和HTTP的区别

*RPC*是远程过程调用（Remote Procedure Call）的缩写形式，并不是一个特定的协议，而是一个概念希望远程的调用像是在本机调用一样简单，无需关心远程的连接问题，所以这个概念推出的很早，HTTP可以算是RPC的一种具体实现，不同的实现都是RPC调用

HTTP是超文本传输协议（Hypertext[ Transfer Protocol](https://baike.baidu.com/item/ Transfer Protocol/612755?fromModule=lemma_inlink)，HTTP）是一个简单的请求-响应协议，它通常运行在[TCP](https://baike.baidu.com/item/TCP/33012?fromModule=lemma_inlink)之上。他是一个协议，规范了传输的信息格式以及得到什么样的相应，他的出现主要是针对浏览器需要对不同公司不同服务器上的服务进行通信，防止通信标准不同而统一规定的协议，早期用于B/S架构，由于HTTP协议的应用广泛，所以C/S架构慢慢也使用了HTTP协议（之前使用的可能是各种各样的协议实现）

所以现在只有在程序内部中服务与服务之间的调用才会使用RPC（也就是各种协议的实现），HTTP兼容性强并且有重定向功能但也相对臃肿，所以性能不如其他RPC





























